#line 203 "D:\marinas-ide(64bits)\harbour\include\hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 58 "D:\GitHub\core\contrib\xhb\xhb.ch"
   EXTERNAL xhb_Lib
#line 10 "D:\GitHub\tbigNumber\src\tTimeCalc.prg"
_HB_CLASS tTimeCalc ; function tTimeCalc ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "tTimeCalc", iif( .F., { }, { @HBObject() } ), @tTimeCalc() ) ) ;

    nScope := 1 ; ( ( nScope ) )

    _HB_MEMBER New() AS CLASS tTimeCalc; oClass:AddMethod( "New", @tTimeCalc_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ClassName(); oClass:AddMethod( "ClassName", @tTimeCalc_ClassName(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER HMSToTime( nHours,nMinuts,nSeconds); oClass:AddMethod( "HMSToTime", @tTimeCalc_HMSToTime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SecsToHMS( nSecsToHMS,nHours,nMinuts,nSeconds,cRet); oClass:AddMethod( "SecsToHMS", @tTimeCalc_SecsToHMS(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SecsToTime( nSecs); oClass:AddMethod( "SecsToTime", @tTimeCalc_SecsToTime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER TimeToSecs( cTime); oClass:AddMethod( "TimeToSecs", @tTimeCalc_TimeToSecs(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SecsToHrs( nSeconds); oClass:AddMethod( "SecsToHrs", @tTimeCalc_SecsToHrs(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER HrsToSecs( nHours); oClass:AddMethod( "HrsToSecs", @tTimeCalc_HrsToSecs(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SecsToMin( nSeconds); oClass:AddMethod( "SecsToMin", @tTimeCalc_SecsToMin(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER MinToSecs( nMinuts); oClass:AddMethod( "MinToSecs", @tTimeCalc_MinToSecs(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER IncTime( cTime,nIncHours,nIncMinuts,nIncSeconds); oClass:AddMethod( "IncTime", @tTimeCalc_IncTime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DecTime( cTime,nDecHours,nDecMinuts,nDecSeconds); oClass:AddMethod( "DecTime", @tTimeCalc_DecTime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Time2NextDay( cTime,dDate); oClass:AddMethod( "Time2NextDay", @tTimeCalc_Time2NextDay(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ExtractTime( cTime,nHours,nMinutes,nSeconds,cRet); oClass:AddMethod( "ExtractTime", @tTimeCalc_ExtractTime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER MediumTime( cTime,nDividendo,lMiliSecs); oClass:AddMethod( "MediumTime", @tTimeCalc_MediumTime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS tTimeCalc ;

static FUNCTION tTimeCalc_New() ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
Return(self)

static FUNCTION tTimeCalc_ClassName() ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
Return("TTIMECALC")

static FUNCTION tTimeCalc_HMSToTime(nHours,nMinuts,nSeconds) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc

    Local cTime

    iif( nHours == NIL , hb_Default(@nHours,0) , )
    iif( nMinuts == NIL , hb_Default(@nMinuts,0) , )
    iif( nSeconds == NIL , hb_Default(@nSeconds,0) , )

    cTime := hb_ntos(nHours)
    cTime := StrZero(Val(cTime),Max(Len(cTime),2))
    cTime += ":"
    cTime += StrZero(Val(hb_ntos(nMinuts)),2)
    cTime += ":"
    cTime += StrZero(Val(hb_ntos(nSeconds)),2)

Return(cTime)

static FUNCTION tTimeCalc_SecsToHMS(nSecsToHMS,nHours,nMinuts,nSeconds,cRet) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc

    Local nRet    := 0

    iif( nSecsToHMS == NIL , hb_Default(@nSecsToHMS,0) , )
    iif( cRet == NIL , hb_Default(@cRet,"H") , )

    nHours        := self:SecsToHrs(nSecsToHMS)
    nMinuts        := self:SecsToMin(nSecsToHMS)
    nSeconds    := (self:HrsToSecs(nHours)+self:MinToSecs(nMinuts))
    nSeconds    := (nSecsToHMS-nSeconds)
    nSeconds    := Int(nSeconds)
    nSeconds    := Mod(nSeconds,60)

    IF (cRet$"Hh")
        nRet := nHours
    ElseIF (cRet$"Mm")
        nRet := nMinuts
    ElseIF (cRet$"Ss")
        nRet := nSeconds
    EndIF

Return(nRet)

static FUNCTION tTimeCalc_SecsToTime(nSecs) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
    Local nHours
    Local nMinuts
    Local nSeconds
    self:SecsToHMS(nSecs,@nHours,@nMinuts,@nSeconds)
Return(self:HMSToTime(nHours,nMinuts,nSeconds))

static FUNCTION tTimeCalc_TimeToSecs(cTime) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc

    Local nHours
    Local nMinuts
    Local nSeconds

    iif( cTime == NIL , hb_Default(@cTime,"00:00:00") , )

    self:ExtractTime(cTime,@nHours,@nMinuts,@nSeconds)

    nMinuts        += (nHours*60)
    nSeconds    += (nMinuts*60)

Return(nSeconds)

static FUNCTION tTimeCalc_SecsToHrs(nSeconds) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
    Local nHours
    nHours    := (nSeconds/3600)
    nHours    := Int(nHours)
Return(nHours)

static FUNCTION tTimeCalc_HrsToSecs(nHours) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
Return((nHours*3600))

static FUNCTION tTimeCalc_SecsToMin(nSeconds) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
    Local nMinuts
    nMinuts        := (nSeconds/60)
    nMinuts        := Int(nMinuts)
    nMinuts        := Mod(nMinuts,60)
Return(nMinuts)

static FUNCTION tTimeCalc_MinToSecs(nMinuts) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
Return((nMinuts*60))

static FUNCTION tTimeCalc_IncTime(cTime,nIncHours,nIncMinuts,nIncSeconds) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc

    Local nSeconds
    Local nMinuts
    Local nHours

    iif( nIncHours == NIL , hb_Default(@nIncHours,0) , )
    iif( nIncMinuts == NIL , hb_Default(@nIncMinuts,0) , )
    iif( nIncSeconds == NIL , hb_Default(@nIncSeconds,0) , )

    self:ExtractTime(cTime,@nHours,@nMinuts,@nSeconds)

    nHours        += nIncHours
    nMinuts        += nIncMinuts
    nSeconds    += nIncSeconds
    nSeconds    := (self:HrsToSecs(nHours)+self:MinToSecs(nMinuts)+nSeconds)

Return(self:SecsToTime(nSeconds))

static FUNCTION tTimeCalc_DecTime(cTime,nDecHours,nDecMinuts,nDecSeconds) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc

    Local nSeconds
    Local nMinuts
    Local nHours

    iif( nDecHours == NIL , hb_Default(@nDecHours,0) , )
    iif( nDecMinuts == NIL , hb_Default(@nDecMinuts,0) , )
    iif( nDecSeconds == NIL , hb_Default(@nDecSeconds,0) , )

    self:ExtractTime(cTime,@nHours,@nMinuts,@nSeconds)

    nHours        -= nDecHours
    nMinuts        -= nDecMinuts
    nSeconds    -= nDecSeconds
    nSeconds    := (self:HrsToSecs(nHours)+self:MinToSecs(nMinuts)+nSeconds)

Return(self:SecsToTime(nSeconds))

static FUNCTION tTimeCalc_Time2NextDay(cTime,dDate) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc
    While (Val(cTime)>=24)
        cTime := self:DecTime(cTime,24)
        ++dDate
    end
Return({cTime,dDate})

static FUNCTION tTimeCalc_ExtractTime(cTime,nHours,nMinutes,nSeconds,cRet) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc

    Local nRet        := 0

    Local nAT

    iif( cTime == NIL , hb_Default(@cTime,"00:00:00") , )
    iif( cRet == NIL , hb_Default(@cRet,"H") , )

    nAT    := AT(":",cTime)

    IF (nAT == 0)
        nHours    := Val(cTime)
        nMinutes:= 0
        nSeconds:= 0
    Else
        nHours    := Val(SubStr(cTime,1,nAT-1))
        cTime    := SubStr(cTime,nAT+1)
        nAT        := (At(":",cTime))
        IF (nAT == 0)
            nMinutes := Val(cTime)
            nSeconds := 0
        Else
            nMinutes := Val(SubStr(cTime,1,nAT-1))
            nSeconds := Val(SubStr(cTime,nAT+1))
        EndIF
    EndIF

    IF (cRet$"Hh")
        nRet := nHours
    ElseIF (cRet$"Mm")
        nRet := nMinutes
    ElseIF (cRet$"Ss")
        nRet := nSeconds
    EndIF

Return(nRet)

static FUNCTION tTimeCalc_MediumTime(cTime,nDividendo,lMiliSecs) ; local Self AS CLASS tTimeCalc := QSelf() AS CLASS tTimeCalc

    Local cMediumTime    := "00:00:00:000"

    Local nSeconds
    Local nMediumTime
    Local nMiliSecs

    iif( nDividendo == NIL , hb_Default(@nDividendo,0) , )

    IF (nDividendo>0)

        nSeconds    := self:TimeToSecs(cTime)
        nSeconds    := (nSeconds/nDividendo)
        nMediumTime    := Int(nSeconds)

        nMiliSecs    := (nSeconds-nMediumTime)
        nMiliSecs    *= 1000
        nMiliSecs    := Int(nMiliSecs)

        cMediumTime    := self:SecsToTime(nMediumTime)

    EndIF

    iif( lMiliSecs == NIL , hb_Default(@lMiliSecs,.T.) , )
    IF (lMiliSecs)
        iif( nMiliSecs == NIL , hb_Default(@nMiliSecs,0) , )
         cMediumTime += (":"+StrZero(nMiliSecs,IF(nMiliSecs>999,4,3)))
    EndIF

Return(cMediumTime)
