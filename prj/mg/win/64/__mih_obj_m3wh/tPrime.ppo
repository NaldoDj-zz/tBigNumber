#line 203 "D:\marinas-ide(64bits)\harbour\include\hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 58 "D:\GitHub\core\contrib\xhb\xhb.ch"
   EXTERNAL xhb_Lib
#line 5 "D:\GitHub\tbigNumber\src\tPrime.prg"
THREAD Static __aPTables
THREAD Static __nPTables

THREAD Static __oIPfRead
THREAD Static __nIPfRead
THREAD Static __aIPLRead

THREAD Static __oNPfRead
THREAD Static __nNPfRead
THREAD Static __aNPLRead













_HB_CLASS tPrime ; function tPrime ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "tPrime", iif( .F., { }, { @HBObject() } ), @tPrime() ) ) ;

; _HB_MEMBER { cPrime } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPrime"}, .F. )
; _HB_MEMBER { cFPrime } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFPrime"}, .F. )
; _HB_MEMBER { cLPrime } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLPrime"}, .F. )

; _HB_MEMBER { nSize } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nSize"}, .F. )

    _HB_MEMBER New( cPath , nLocal) AS CLASS tPrime; oClass:AddMethod( "New", @tPrime_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER ClassName(); oClass:AddMethod( "ClassName", @tPrime_ClassName(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER IsPrime( cN,lForce); oClass:AddMethod( "IsPrime", @tPrime_IsPrime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER IsPReset(); oClass:AddMethod( "IsPReset", @tPrime_IsPReset(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER NextPrime( cN,lForce); oClass:AddMethod( "NextPrime", @tPrime_NextPrime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER NextPReset(); oClass:AddMethod( "NextPReset", @tPrime_NextPReset(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER ResetAll(); oClass:AddMethod( "ResetAll", @tPrime_ResetAll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS tPrime ;




















static FUNCTION tPrime_New( cPath , nLocal ) ; local Self AS CLASS tPrime := QSelf() AS CLASS tPrime

    Local aLine
    Local aFiles

    Local cLine
    Local cFile

    Local cFPrime
    Local cLPrime

    Local nSize
    Local nLine
    Local nFile
    Local nFiles
    Local ofRead

    iif( __aPTables == NIL , hb_Default(@__aPTables,Array(0)) , )

    IF Empty( __aPTables )
        self:nSize    := 10

            iif( cPath == NIL , hb_Default(@cPath,hb_CurDrive()+hb_osDriveSeparator()+hb_osPathSeparator()+CurDir()+hb_osPathSeparator()+"PrimesTables"+hb_osPathSeparator()) , )



        aFiles    := Directory( cPath + "prime*.txt" )
        nFiles    := Len( aFiles )
        nSize    := 10
        ofRead    := tfRead():New()
        For nFile := 1 To nFiles
            cFile    := cPath+aFiles[nFile][1]
            nLine    := 0
            ofRead:Open(cFile,NIL,nLocal)
            ofRead:ReadLine()
            While ofRead:MoreToRead()
                cLine := ofRead:ReadLine()
                IF Empty(cLine)
                    Loop
                EndIF
                nLine    := Max(nLine,Len(cLine))
                While "  " $ cLine
                    cLine    := StrTran(cLine,"  "," ")
                end
                While SubStr(cLine,1,1) == " "
                    cLine := SubStr(cLine,2)
                end
                While SubStr(cLine,-1) == " "
                    cLine := SubStr(cLine,1,Len(cLine)-1)
                end

                     aLine := hb_ATokens(cLine," ")



                cFPrime := aLine[1]
                nSize    := Max(Len(cFPrime),nSize)
                cFPrime := PadL(cFPrime,nSize)
                EXIT
            end
            ofRead:Seek( -nLine , 2 )
            While ofRead:MoreToRead()
                cLine := ofRead:ReadLine()
                IF Empty(cLine)
                    Loop
                EndIF
                nLine    := Max(nLine,Len(cLine))
                While "  " $ cLine
                    cLine    := StrTran(cLine,"  "," ")
                end
                While SubStr(cLine,1,1) == " "
                    cLine := SubStr(cLine,2)
                end
                While SubStr(cLine,-1) == " "
                    cLine := SubStr(cLine,1,Len(cLine)-1)
                end

                     aLine := hb_ATokens(cLine," ")



                cLPrime := aLine[Len(aLine)]
                nSize    := Max(Len(cFPrime),nSize)
                cLPrime := PadL(cLPrime,nSize)
                EXIT
            end
            ofRead:Close(.T.)
            aAdd( __aPTables , { cFile , cFPrime , cLPrime , nLine } )
        next

        nFiles    := Len( __aPTables )
        IF nFiles > 0
            IF nSize > self:nSize
                self:nSize := nSize
                For nFile := 1 To nFiles
                    __aPTables[nFile][2] := PadL(__aPTables[nFile][2],nSize)
                    __aPTables[nFile][3] := PadL(__aPTables[nFile][3],nSize)
                next
            EndIF
            aSort( __aPTables , NIL , NIL , { |x,y| x[2] < y[2] } )
            self:cFPrime    := __aPTables[1][2]
            self:cLPrime    := __aPTables[nFiles][3]
        EndIF

        __nPTables    := nFiles

    Else

        nFiles    := __nPTables
        IF nFiles > 0
            self:cFPrime    := __aPTables[1][2]
            self:cLPrime    := __aPTables[nFiles][3]
            self:nSize         := Len( self:cLPrime )
        EndIF

    EndIF

    self:cPrime    := ""

    IF self:cFPrime == NIL
        self:cFPrime := ""
    EndIF

    IF self:cLPrime == NIL
        self:cLPrime := ""
    EndIF

    IF self:nSize == NIL
        self:nSize := Len(self:cLPrime)
    EndIF

Return( self )








static FUNCTION tPrime_ClassName() ; local Self AS CLASS tPrime := QSelf() AS CLASS tPrime
Return( "TPRIME" )








static FUNCTION tPrime_IsPrime(cN,lForce) ; local Self AS CLASS tPrime := QSelf() AS CLASS tPrime

    Local aLine

    Local cLine

    Local lPrime    := .F.

    Local nPrime
    Local nTable

    BEGIN SEQUENCE

        IF Empty( __aPTables )
            BREAK
        EndIF

        iif( cN == NIL , hb_Default(@cN,self:cPrime) , )
        cN            := PadL( cN , self:nSize )

        nTable        := aScan( __aPTables , { |x| cN >= x[2] .AND. cN <= x[3] } )

        IF nTable == 0
            BREAK
        ENDIF

        iif( __oIPfRead == NIL , hb_Default(@__oIPfRead,tfRead():New()) , )
        iif( __aIPLRead == NIL , hb_Default(@__aIPLRead,Array(0)) , )

        iif( lForce == NIL , hb_Default(@lForce,.F.) , )
        IF ( lForce )
            Self:IsPReset()
        EndIF

        IF !( __nIPfRead == nTable )
            Self:IsPReset()
            __nIPfRead := nTable
            __oIPfRead:Close(.T.)
            __oIPfRead:Open(__aPTables[nTable][1])
            __oIPfRead:nReadSize := MIN( 65535 , ( __aPTables[nTable][4] + 2 ) * 64 )
            __oIPfRead:ReadLine()
        EndIF

        nPrime    := aScan( __aIPLRead , { |x| PadL(x,self:nSize) == cN } )
        IF ( lPrime := nPrime > 0 )
            BREAK
        EndIF

        While __oIPfRead:MoreToRead()
            cLine := __oIPfRead:ReadLine()
            IF Empty(cLine)
                Loop
            EndIF
            While "  " $ cLine
                cLine    := StrTran(cLine,"  "," ")
            end
            While SubStr(cLine,1,1) == " "
                cLine := SubStr(cLine,2)
            end
            While SubStr(cLine,-1) == " "
                cLine := SubStr(cLine,1,Len(cLine)-1)
            end

                 aLine := hb_ATokens(cLine," ")



            nPrime    := aScan( aLine , { |x| PadL(x,self:nSize) == cN } )
            IF ( lPrime := nPrime > 0 )
                EXIT
            EndIF
            IF aScan( aLine , { |x| PadL(x,self:nSize) > cN } ) > 0
                EXIT
            EndIF
        end

        aSize( __aIPLRead ,  0 )

        IF !( Empty( aLine ) )
            aEval( aLine , { |x| aAdd( __aIPLRead , x ) } )
        EndIF

    end

Return( lPrime )








static FUNCTION tPrime_IsPReset() ; local Self AS CLASS tPrime := QSelf() AS CLASS tPrime
    __nIPfRead    := NIL
    IF !( __aIPLRead == NIL )
        aSize( __aIPLRead , 0 )
    EndIF
Return( .T. )








static FUNCTION tPrime_NextPrime(cN,lForce) ; local Self AS CLASS tPrime := QSelf() AS CLASS tPrime

    Local aLine

    Local cLine
    Local cPrime

    Local lPrime    := .F.

    Local nPrime
    Local nTable

    BEGIN SEQUENCE

        IF Empty( __aPTables )
            BREAK
        EndIF

        iif( cN == NIL , hb_Default(@cN,self:cPrime) , )
        cN            := PadL( cN , self:nSize )
        self:cPrime    := cN

        IF Empty( cN )
            nTable := 1
        Else
            nTable    := aScan( __aPTables , { |x| cN >= x[2] .AND. cN <= x[3] } )
        EndIF

        IF nTable == 0
            BREAK
        ENDIF

        iif( __oNPfRead == NIL , hb_Default(@__oNPfRead,tfRead():New()) , )
        iif( __aNPLRead == NIL , hb_Default(@__aNPLRead,Array(0)) , )

        iif( lForce == NIL , hb_Default(@lForce,.F.) , )
        IF ( lForce )
            Self:NextPReset()
        EndIF

        IF !( __nNPfRead == nTable )
            Self:NextPReset()
            __nNPfRead := nTable
            __oNPfRead:Close(.T.)
            __oNPfRead:Open(__aPTables[nTable][1])
            __oNPfRead:nReadSize := MIN( 65535 , ( __aPTables[nTable][4] + 2 ) * 64 )
            __oNPfRead:ReadLine()
        EndIF

        nPrime    := aScan( __aNPLRead , { |x| ( cPrime := PadL(x,self:nSize) ) > cN } )
        IF ( lPrime := nPrime > 0 )
            self:cPrime := cPrime
            BREAK
        EndIF

        While __oNPfRead:MoreToRead()
            cLine := __oNPfRead:ReadLine()
            IF Empty(cLine)
                Loop
            EndIF
            While "  " $ cLine
                cLine    := StrTran(cLine,"  "," ")
            end
            While SubStr(cLine,1,1) == " "
                cLine := SubStr(cLine,2)
            end
            While SubStr(cLine,-1) == " "
                cLine := SubStr(cLine,1,Len(cLine)-1)
            end

                 aLine := hb_ATokens(cLine," ")



            nPrime    := aScan( aLine , { |x| ( cPrime := PadL(x,self:nSize) ) > cN } )
            IF ( lPrime := nPrime > 0 )
                EXIT
            EndIF
        end

        aSize( __aNPLRead ,  0 )

        IF !( Empty( aLine ) )
            aEval( aLine , { |x| aAdd( __aNPLRead , x ) } )
        EndIF

        iif( cPrime == NIL , hb_Default(@cPrime,"") , )
        self:cPrime     := cPrime

    end

Return( lPrime )








static FUNCTION tPrime_NextPReset() ; local Self AS CLASS tPrime := QSelf() AS CLASS tPrime
    __nNPfRead    := 0
    IF !( __aNPLRead == NIL )
        aSize( __aNPLRead , 0 )
    EndIF
Return( .T. )








static FUNCTION tPrime_ResetAll() ; local Self AS CLASS tPrime := QSelf() AS CLASS tPrime
    __nPTables    := 0
    IF !( __aPTables == NIL )
        aSize( __aPTables , 0 )
    EndIF
    Self:IsPReset()
    Self:NextPReset()
Return( .T. )
