#line 203 "D:\marinas-ide(64bits)\harbour\include\hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 28 "D:\GitHub\tbigNumber\src\tfRead.prg"
Static __cCHR13
Static __cCHR10









_HB_CLASS tfRead ; function tfRead ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "tfRead", iif( .F., { }, { @HBObject() } ), @tfRead() ) ) ;

; _HB_MEMBER { cFile } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFile"}, .F. )
; _HB_MEMBER { nfHandle } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nfHandle"}, .F. )
; _HB_MEMBER { lEOF } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lEOF"}, .F. )
; _HB_MEMBER { nError } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nError"}, .F. )
; _HB_MEMBER { nLastOp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLastOp"}, .F. )
; _HB_MEMBER { cBuffer } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cBuffer"}, .F. )
; _HB_MEMBER { nReadSize } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nReadSize"}, .F. )

    _HB_MEMBER New( cFile,nSize) AS CLASS tfRead; oClass:AddMethod( "New", @tfRead_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ClassName(); oClass:AddMethod( "ClassName", @tfRead_ClassName(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Open( cFile,nMode,nLocal); oClass:AddMethod( "Open", @tfRead_Open(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Seek( nOffset,nOrigin); oClass:AddMethod( "Seek", @tfRead_Seek(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Close( lFClear); oClass:AddMethod( "Close", @tfRead_Close(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ReadLine(); oClass:AddMethod( "ReadLine", @tfRead_ReadLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Name(); oClass:AddMethod( "Name", @tfRead_Name(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER IsOpen(); oClass:AddMethod( "IsOpen", @tfRead_IsOpen(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER MoreToRead(); oClass:AddMethod( "MoreToRead", @tfRead_MoreToRead(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Error(); oClass:AddMethod( "Error", @tfRead_Error(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ErrorNo(); oClass:AddMethod( "ErrorNo", @tfRead_ErrorNo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ErrorMsg( cText); oClass:AddMethod( "ErrorMsg", @tfRead_ErrorMsg(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS tfRead ;

static FUNCTION tfRead_New(cFile,nSize) ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

    __cCHR13    := IF( __cCHR13 == NIL , CHR(13) , __cCHR13 )
    __cCHR10    := IF( __cCHR10 == NIL , CHR(10) , __cCHR10 )

    IF nSize == NIL .OR. nSize < 1


        nSize := 4096
    ENDIF

    IF cFile == NIL
        cFile := ""
    EndIF

    self:cFile     := cFile
    self:nfHandle  := -1
    self:lEOF      := .T.
    self:nError    := 0
    self:nLastOp   := 1
    self:cBuffer   := ""
    self:nReadSize := nSize

RETURN Self






static FUNCTION tfRead_ClassName() ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead
Return("TFREAD")

static FUNCTION tfRead_Open(cFile,nMode,nLocal) ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

    IF !( cFile == NIL )
        IF !( cFile == self:cFile )
            self:Close(.T.)
        EndIF
    EndIF

    IF self:nfHandle == -1
        IF Empty( self:cFile ) .AND. !(Empty(cFile))
            self:cFile := cFile
        EndIF

        IF nMode == NIL
            nMode := 0 + 64
        ENDIF
        self:nLastOp     := 2






            ( nLocal := ( nLocal ) )
            self:nfHandle    := FOPEN( self:cFile, nMode )

        IF self:nfHandle == -1
            self:nError := FERROR()
            self:lEOF   := .T.
        ELSE
            self:nError := 0
            self:lEOF   := .F.
        ENDIF
    ELSE

        IF self:Seek( 0 ) == 0
            self:lEOF := .F.
        ELSE
            self:nError := FERROR()
        ENDIF
    ENDIF

    self:cBuffer := ""

RETURN Self

static FUNCTION tfRead_Seek(nOffset,nOrigin) ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

    Local nPosition := -1

    self:nLastOp    := 5
    self:cBuffer     := ""
    IF self:nfHandle == -1
        self:nError := -1
    Else
        nOffset         := IF(nOffset==NIL,0,nOffset)
        nOrigin         := IF(nOrigin==NIL,1,nOrigin)
        nPosition        := FSEEK( self:nfHandle , nOffset , nOrigin )
        self:nError     := FERROR()
    EndIF

Return( nPosition )

static FUNCTION tfRead_ReadLine() ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

   LOCAL cLine := ""
   LOCAL nPos

   self:nLastOp := 3

   IF self:nfHandle == -1
      self:nError := -1
   ELSE

      nPos := f_EOL_pos( Self )
      WHILE ( nPos <= 0 .OR. nPos > LEN( self:cBuffer ) - 3 ) .AND. !self:lEOF




         cLine := FREADSTR( self:nfHandle, self:nReadSize )
         IF EMPTY( cLine )

            self:nError := FERROR()
            IF self:nError == 0

               self:lEOF := .T.
            ENDIF
         ELSE

            self:cBuffer += cLine
         ENDIF

         nPos := f_EOL_pos( Self )
      end

      IF nPos <= 0


         cLine := self:cBuffer
         self:cBuffer := ""
      ELSE

         IF nPos > 1

            cLine := LEFT( self:cBuffer, nPos - 1 )
         ELSE

            cLine := ""
         ENDIF

         DO CASE
            CASE SUBSTR( self:cBuffer, nPos, 3 ) == __cCHR10 + __cCHR13 + __cCHR10
               nPos += 3
            CASE SUBSTR( self:cBuffer, nPos, 3 ) == __cCHR13 + __cCHR13 + __cCHR10



               nPos += 3
            CASE SUBSTR( self:cBuffer, nPos, 2 ) == __cCHR13 + __cCHR10

               nPos += 2
            OTHERWISE

               nPos++
         ENDCASE
         self:cBuffer := SUBSTR( self:cBuffer, nPos )
      ENDIF
   ENDIF

RETURN cLine

Static Function f_EOL_pos( oFile )

   LOCAL nCRpos, nLFpos, nPos


   nCRpos := AT( __cCHR13, oFile:cBuffer )
   nLFpos := AT( __cCHR10, oFile:cBuffer )
   DO CASE
      CASE nCRpos == 0

         nPos := nLFpos
      CASE nLFpos == 0

         nPos := nCRpos
      OTHERWISE

         nPos := MIN( nCRpos, nLFpos )
   ENDCASE

RETURN nPos

static FUNCTION tfRead_Close(lFClear) ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

    self:nLastOp := 4
    self:lEOF := .T.

    IF self:nfHandle == -1

        self:nError := -1
    ELSE

        FCLOSE( self:nfHandle )
        self:nError     := FERROR()
        self:nfHandle    := -1
        self:lEOF       := .T.
    ENDIF

    IF IF( lFClear == NIL , .F. , lFClear )
        self:cFile := ""
    EndIF

    self:cBuffer := ""

RETURN Self

static FUNCTION tfRead_Name() ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

RETURN self:cFile

static FUNCTION tfRead_IsOpen() ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

RETURN self:nfHandle <> -1

static FUNCTION tfRead_MoreToRead() ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead


RETURN !self:lEOF .OR. !EMPTY( self:cBuffer )

static FUNCTION tfRead_Error() ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

RETURN self:nError <> 0

static FUNCTION tfRead_ErrorNo() ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

RETURN self:nError

static FUNCTION tfRead_ErrorMsg( cText ) ; local Self AS CLASS tfRead := QSelf() AS CLASS tfRead

   STATIC s_cAction := {"on", "creating object for", "opening", "reading from", "closing" , "seeking"}

   LOCAL cMessage, nTemp


   IF self:nError == 0

      cMessage := "No errors have been recorded for " + self:cFile
   ELSE

      IF self:nLastOp < 1 .OR. self:nLastOp > 5
         nTemp := 1
      ELSE
         nTemp := self:nLastOp + 1
      ENDIF
      cMessage := IF( EMPTY( cText ), "", cText ) + "Error " + hb_ntos( self:nError ) + " " + s_cAction[ nTemp ] + " " + self:cFile
   ENDIF

RETURN cMessage
